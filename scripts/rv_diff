#!/usr/bin/env python3
"""
Find the first divergence between two CPU trace files.

Compares MEM and WB stage operations (which represent committed instructions)
to find the first divergence. These stages are used because they represent
instructions that have actually completed, unlike EX which may contain
flushed instructions.
"""

import argparse
import re
from dataclasses import dataclass
from typing import List, Optional


@dataclass
class MemEntry:
    """Represents a memory operation in MEM stage"""
    line_num: int
    time: int
    pc: str
    op_type: str  # "r" (read) or "w" (write)
    addr: str
    raw_line: str


@dataclass
class WbEntry:
    """Represents a register writeback (WB)"""
    line_num: int
    time: int
    pc: str
    data: str
    reg: str
    raw_line: str


def extract_mem_entries(filename: str) -> List[MemEntry]:
    """Extract all memory operations from a trace file

    Format: M   <pc> r/w <addr>
    """
    entries = []

    with open(filename, 'r') as f:
        for line_num, line in enumerate(f, 1):
            line = line.strip()
            if not line:
                continue

            if not (line.startswith("svc_rv") or line.startswith("[")):
                continue

            time_match = re.search(r'\[\s*(\d+)\]', line)
            if not time_match:
                continue

            time = int(time_match.group(1))

            parts = line.split('|')
            if len(parts) < 4:
                continue

            mem_part = parts[3]

            #
            # Format: M   <pc> r/w <addr>
            #
            mem_match = re.search(
                r'M\s+([0-9a-fA-Fx]+)\s+([rw])\s+([0-9a-fA-Fx]+)',
                mem_part
            )
            if mem_match:
                entries.append(MemEntry(
                    line_num=line_num,
                    time=time,
                    pc=mem_match.group(1),
                    op_type=mem_match.group(2),
                    addr=mem_match.group(3),
                    raw_line=line
                ))

    return entries


def extract_wb_entries(filename: str) -> List[WbEntry]:
    """Extract all register writeback operations (WB) from a trace file

    Format: WB <pc> <data> -> <reg>
    """
    entries = []

    with open(filename, 'r') as f:
        for line_num, line in enumerate(f, 1):
            line = line.strip()
            if not line:
                continue

            if not (line.startswith("svc_rv") or line.startswith("[")):
                continue

            time_match = re.search(r'\[\s*(\d+)\]', line)
            if not time_match:
                continue

            time = int(time_match.group(1))

            parts = line.split('|')
            if len(parts) < 5:
                continue

            wb_part = parts[4]

            #
            # Format: WB <pc> <data> -> <reg>
            #
            wb_match = re.search(
                r'WB\s+([0-9a-fA-Fx]+)\s+([0-9a-fA-Fx]+)\s+->\s+(x\d+)',
                wb_part
            )
            if wb_match:
                entries.append(WbEntry(
                    line_num=line_num,
                    time=time,
                    pc=wb_match.group(1),
                    data=wb_match.group(2),
                    reg=wb_match.group(3),
                    raw_line=line
                ))

    return entries


def collapse_consecutive_wb(entries: List[WbEntry]) -> List[WbEntry]:
    """Collapse consecutive identical WB entries (stall cycle duplicates)

    During pipeline stalls, the same WB content is logged repeatedly.
    This collapses those duplicates so we only compare actual committed
    instructions.

    Note: This is NOT applied to MEM entries because MMIO writes are not
    idempotent (e.g., each UART write has a side effect).
    """
    if not entries:
        return entries

    result = [entries[0]]
    for entry in entries[1:]:
        prev = result[-1]
        if (entry.pc != prev.pc or
                entry.data != prev.data or
                entry.reg != prev.reg):
            result.append(entry)
    return result


def compare_mem_entries(
    file1_entries: List[MemEntry],
    file2_entries: List[MemEntry],
    verbose: bool = False
) -> Optional[tuple]:
    """Compare MEM entries and return divergence info if found"""

    #
    # Compare only the common prefix.
    #
    # For timeout-limited runs, one trace may legitimately end earlier while
    # still matching up to its last committed operation. Treat "trace ended"
    # as non-divergence and report the length mismatch separately.
    #
    max_entries = min(len(file1_entries), len(file2_entries))

    for i in range(max_entries):
        entry1 = file1_entries[i]
        entry2 = file2_entries[i]

        if verbose:
            print(f"MEM Entry {i}: File1 time={entry1.time}, File2 time={entry2.time}")

        #
        # Compare PC, op_type, and address
        #
        if (entry1.pc != entry2.pc or
                entry1.op_type != entry2.op_type or
                entry1.addr != entry2.addr):
            return (i, entry1, entry2, min(entry1.time, entry2.time))

    return None


def compare_wb_entries(
    file1_entries: List[WbEntry],
    file2_entries: List[WbEntry],
    verbose: bool = False
) -> Optional[tuple]:
    """Compare WB entries and return divergence info if found"""

    #
    # Compare only the common prefix.
    #
    # For timeout-limited runs, one trace may legitimately end earlier while
    # still matching up to its last committed instruction. Treat "trace ended"
    # as non-divergence and report the length mismatch separately.
    #
    max_entries = min(len(file1_entries), len(file2_entries))

    for i in range(max_entries):
        entry1 = file1_entries[i]
        entry2 = file2_entries[i]

        if verbose:
            print(f"WB Entry {i}: File1 time={entry1.time}, File2 time={entry2.time}")

        #
        # Compare PC, data, and register
        #
        if (entry1.pc != entry2.pc or
                entry1.data != entry2.data or
                entry1.reg != entry2.reg):
            return (i, entry1, entry2, min(entry1.time, entry2.time))

    return None


def find_divergence(file1: str, file2: str, verbose: bool = False):
    """Find and report the earliest divergence between traces"""

    file1_mem = extract_mem_entries(file1)
    file2_mem = extract_mem_entries(file2)

    #
    # Collapse consecutive identical WB entries (stall cycle duplicates)
    #
    file1_wb = collapse_consecutive_wb(extract_wb_entries(file1))
    file2_wb = collapse_consecutive_wb(extract_wb_entries(file2))

    mem_div = compare_mem_entries(file1_mem, file2_mem, verbose)
    wb_div = compare_wb_entries(file1_wb, file2_wb, verbose)

    if mem_div is None and wb_div is None:
        suffix = ""
        if len(file1_mem) != len(file2_mem) or len(file1_wb) != len(file2_wb):
            suffix = (
                f" (common prefix match; MEM {len(file1_mem)}/{len(file2_mem)}, "
                f"WB {len(file1_wb)}/{len(file2_wb)})"
            )
        print(f"No divergence found{suffix}")
        return

    #
    # Find the earliest divergence
    #
    divergences = []
    if mem_div:
        divergences.append(("MEM", mem_div))
    if wb_div:
        divergences.append(("WB", wb_div))

    divergences.sort(key=lambda x: x[1][3])
    earliest_type, earliest_div = divergences[0]

    idx, entry1, entry2, _ = earliest_div

    #
    # Print divergence header
    #
    time1 = entry1.time if entry1 else "END"
    time2 = entry2.time if entry2 else "END"
    print(f"\n{earliest_type} divergence at time {time1} / {time2}:")
    print()

    #
    # Print stage-specific details
    #
    if earliest_type == "MEM":
        if entry1:
            op_name = "read" if entry1.op_type == "r" else "write"
            print(f"  FILE1: MEM {entry1.pc} {op_name} {entry1.addr}")
        else:
            print(f"  FILE1: (trace ended)")

        if entry2:
            op_name = "read" if entry2.op_type == "r" else "write"
            print(f"  FILE2: MEM {entry2.pc} {op_name} {entry2.addr}")
        else:
            print(f"  FILE2: (trace ended)")

    elif earliest_type == "WB":
        if entry1:
            print(f"  FILE1: WB {entry1.pc} {entry1.data} -> {entry1.reg}")
        else:
            print(f"  FILE1: (trace ended)")

        if entry2:
            print(f"  FILE2: WB {entry2.pc} {entry2.data} -> {entry2.reg}")
        else:
            print(f"  FILE2: (trace ended)")

    print()

    #
    # Print full trace lines for context
    #
    print("Full trace lines:")
    if entry1:
        print(f"  FILE1: {entry1.raw_line}")
    else:
        print(f"  FILE1: (trace ended)")

    if entry2:
        print(f"  FILE2: {entry2.raw_line}")
    else:
        print(f"  FILE2: (trace ended)")


def main():
    parser = argparse.ArgumentParser(
        description="Find the first divergence between two CPU trace files (MEM and WB)"
    )
    parser.add_argument(
        "file1",
        help="Path to the first trace file"
    )
    parser.add_argument(
        "file2",
        help="Path to the second trace file"
    )
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Verbose output (show progress)"
    )

    args = parser.parse_args()

    find_divergence(args.file1, args.file2, args.verbose)


if __name__ == "__main__":
    main()
