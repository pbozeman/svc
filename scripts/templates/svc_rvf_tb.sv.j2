// vim: filetype=systemverilog
//
// Re-run formal: make rv_{{ formal_target }}_f
//
`define RISCV_FORMAL 1
`define RISCV_FORMAL_ALTOPS 1

`include "svc_unit.sv"
`include "svc_rv.sv"

module {{ name }};
  `TEST_CLK_NS(clk, 10);

  logic rst_n;

  //
  // Instruction memory signals
  //
  logic        imem_arvalid;
  logic [31:0] imem_araddr;
  logic [31:0] imem_rdata;
  logic        imem_rvalid;

  //
  // Data memory signals
  //
  logic        dmem_ren;
  logic [31:0] dmem_raddr;
  logic [31:0] dmem_rdata;
  logic        dmem_we;
  logic [31:0] dmem_waddr;
  logic [31:0] dmem_wdata;
  logic [ 3:0] dmem_wstrb;

  logic ebreak;
  logic trap;

  //
  // RVFI signals for spec checking
  //
  logic        rvfi_valid;
  logic [63:0] rvfi_order;
  logic [31:0] rvfi_pc_wdata;
  logic [ 4:0] rvfi_rd_addr;
  logic [31:0] rvfi_rd_wdata;
  logic [ 4:0] rvfi_rs1_addr;
  logic [ 4:0] rvfi_rs2_addr;
  logic [31:0] rvfi_rs1_rdata;
  logic [31:0] rvfi_rs2_rdata;
  logic        rvfi_trap;
  logic [31:0] rvfi_mem_addr;
  logic [ 3:0] rvfi_mem_rmask;
  logic [ 3:0] rvfi_mem_wmask;

  //
  // CPU under test
  //
  svc_rv #(
      .PIPELINED  ({{ pipelined }}),
      .FWD        ({{ fwd }}),
      .FWD_REGFILE({{ fwd_regfile }}),
      .MEM_TYPE   ({{ mem_type }}),
      .BPRED      ({{ bpred }}),
      .BTB_ENABLE ({{ btb_enable }}),
      .RAS_ENABLE ({{ ras_enable }}),
      .EXT_M      ({{ ext_m }}),
      .EXT_ZMMUL  ({{ ext_zmmul }})
  ) uut (
      .clk  (clk),
      .rst_n(rst_n),

      .imem_arvalid(imem_arvalid),
      .imem_araddr (imem_araddr),
      .imem_rdata  (imem_rdata),
      .imem_rvalid (imem_rvalid),

      .dmem_ren  (dmem_ren),
      .dmem_raddr(dmem_raddr),
      .dmem_rdata(dmem_rdata),

      .dmem_we   (dmem_we),
      .dmem_waddr(dmem_waddr),
      .dmem_wdata(dmem_wdata),
      .dmem_wstrb(dmem_wstrb),

      .rvfi_valid    (rvfi_valid),
      .rvfi_order    (rvfi_order),
      .rvfi_pc_wdata (rvfi_pc_wdata),
      .rvfi_rd_addr  (rvfi_rd_addr),
      .rvfi_rd_wdata (rvfi_rd_wdata),
      .rvfi_rs1_addr (rvfi_rs1_addr),
      .rvfi_rs2_addr (rvfi_rs2_addr),
      .rvfi_rs1_rdata(rvfi_rs1_rdata),
      .rvfi_rs2_rdata(rvfi_rs2_rdata),
      .rvfi_trap     (rvfi_trap),
      .rvfi_mem_addr (rvfi_mem_addr),
      .rvfi_mem_rmask(rvfi_mem_rmask),
      .rvfi_mem_wmask(rvfi_mem_wmask),

      .ebreak(ebreak),
      .trap  (trap)
  );

  //
  // Sparse instruction memory from trace
  //
{% if pipelined == 1 %}
  //
  // Pipelined timing: 1-cycle latency (address at edge N, data at edge N+1)
  //
  logic [31:0] imem_rdata_any;
  logic [31:0] imem_rdata_reg;
  logic        imem_rvalid_reg;

  always_comb begin
    case (imem_araddr)
{% for addr, insn in imem %}
      32'h{{ '%08x' % addr }}: imem_rdata_any = 32'h{{ '%08x' % insn }};
{% endfor %}
      default:      imem_rdata_any = 32'h00000013;
    endcase
  end

  always_ff @(posedge clk) begin
    if (!rst_n) begin
      imem_rdata_reg  <= 32'h00000013;
      imem_rvalid_reg <= 1'b0;
    end else begin
      imem_rvalid_reg <= imem_arvalid;
      if (imem_arvalid) begin
        imem_rdata_reg <= imem_rdata_any;
      end
    end
  end

  assign imem_rdata  = imem_rdata_reg;
  assign imem_rvalid = imem_rvalid_reg;
{% else %}
  //
  // Single-cycle timing: combinational (0-cycle latency)
  //
  always_comb begin
    case (imem_araddr)
{% for addr, insn in imem %}
      32'h{{ '%08x' % addr }}: imem_rdata = 32'h{{ '%08x' % insn }};
{% endfor %}
      default:      imem_rdata = 32'h00000013;
    endcase
  end

  assign imem_rvalid = imem_arvalid;
{% endif %}

  //
  // Data memory - per-cycle values from formal trace
  //
  // The formal solver provides specific dmem_rdata values at specific cycles.
  // We replicate this exactly to reproduce the counterexample.
  //
  int dmem_cycle;
  logic [31:0] dmem_rdata_any;
  logic [31:0] dmem_rdata_reg;

  //
  // Per-cycle dmem values from trace_tb.v
  //
  // Formal's cycle N means: dmem_rdata_any should be X at cycle N, and
  // dmem_rdata_reg captures it at the posedge transitioning from N to N+1.
  // But in Verilog, always_comb sees the OLD dmem_cycle value at posedge,
  // so we need case(N-1) to match formal's cycle N timing.
  //
  always_comb begin
    case (dmem_cycle)
{% for cycle, data in dmem %}
      {{ cycle - 1 }}: dmem_rdata_any = 32'h{{ '%08x' % data }};
{% endfor %}
      default: dmem_rdata_any = 32'h{{ '%08x' % dmem_init }};
    endcase
  end

  //
  // BRAM timing for data memory (matches formal wrapper)
  //
{% if mem_type == 1 %}
  always_ff @(posedge clk) begin
    if (!rst_n) begin
      dmem_rdata_reg <= 32'hxxxxxxxx;
    end else if (dmem_ren) begin
      dmem_rdata_reg <= dmem_rdata_any;
    end
  end
  assign dmem_rdata = dmem_rdata_reg;
{% else %}
  assign dmem_rdata = dmem_ren ? dmem_rdata_any : 32'hxxxxxxxx;
{% endif %}

  //
  // Track cycle count for dmem timing
  //
  always_ff @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
      dmem_cycle <= -1;
    end else begin
      dmem_cycle <= dmem_cycle + 1;
    end
  end

  //
  // Reset and state initialization from trace
  //
  // Initialize all non-zero registers from the formal trace at t=0.
  // This includes register file, pipeline registers, and other state.
  //
  initial begin
    $display("Re-run formal:");
    $display("make rv_{{ formal_target }}_f\n");
    rst_n = 1'b0;
{% for item in init_state %}
{% if item[3] %}
    force uut.{{ item[0] }} = {{ item[2] }}'h{{ '%x' % item[1] }};
{% else %}
    uut.{{ item[0] }} = {{ item[2] }}'h{{ '%x' % item[1] }};
{% endif %}
{% endfor %}
    #10;
    rst_n = 1'b1;
    //
    // Release forced signals after reset
    //
{% for item in init_state %}
{% if item[3] %}
    release uut.{{ item[0] }};
{% endif %}
{% endfor %}
  end

  //
  // Test: run trace and check spec assertions
  //
  task automatic test_trace();
{% for check in spec_checks %}
    `CHECK_WAIT_FOR(clk, rvfi_valid && rvfi_order == {{ check.order }}, {{ max_cycles }});
{% if check.spec_pc_wdata is defined %}
    `CHECK_EQ(rvfi_pc_wdata, 32'h{{ '%08x' % check.spec_pc_wdata }});
{% endif %}
{% if check.spec_rd_addr is defined %}
    `CHECK_EQ(rvfi_rd_addr, 5'd{{ check.spec_rd_addr }});
{% endif %}
{% if check.spec_rd_wdata is defined %}
    `CHECK_EQ(rvfi_rd_wdata, 32'h{{ '%08x' % check.spec_rd_wdata }});
{% endif %}
{% if check.spec_rs1_addr is defined and check.spec_rs1_addr != 0 %}
    `CHECK_EQ(rvfi_rs1_addr, 5'd{{ check.spec_rs1_addr }});
{% endif %}
{% if check.spec_rs2_addr is defined and check.spec_rs2_addr != 0 %}
    `CHECK_EQ(rvfi_rs2_addr, 5'd{{ check.spec_rs2_addr }});
{% endif %}
{% if check.spec_trap is defined %}
    `CHECK_EQ(rvfi_trap, 1'b{{ check.spec_trap }});
{% endif %}
{% if check.spec_mem_rmask is defined %}
    `CHECK_EQ(rvfi_mem_rmask, 4'h{{ '%x' % check.spec_mem_rmask }});
{% endif %}
{% if check.spec_mem_wmask is defined %}
    `CHECK_EQ(rvfi_mem_wmask, 4'h{{ '%x' % check.spec_mem_wmask }});
{% endif %}
{% if check.spec_mem_addr is defined and (check.spec_mem_rmask is defined and check.spec_mem_rmask != 0) or (check.spec_mem_wmask is defined and check.spec_mem_wmask != 0) %}
    `CHECK_EQ(rvfi_mem_addr, 32'h{{ '%08x' % check.spec_mem_addr }});
{% endif %}
{% endfor %}
{% for check in reg_checks %}
    `CHECK_WAIT_FOR(clk, rvfi_valid && rvfi_order == {{ check.order }}, {{ max_cycles }});
{% if check.register_index is defined and check.register_shadow is defined %}
{% if check.rvfi_rs1_addr is defined and check.rvfi_rs1_addr == check.register_index %}
    `CHECK_EQ(rvfi_rs1_rdata, 32'h{{ '%08x' % check.register_shadow }});
{% endif %}
{% if check.rvfi_rs2_addr is defined and check.rvfi_rs2_addr == check.register_index %}
    `CHECK_EQ(rvfi_rs2_rdata, 32'h{{ '%08x' % check.register_shadow }});
{% endif %}
{% endif %}
{% endfor %}
  endtask

  //
  // Test suite
  //
  `TEST_SUITE_BEGIN({{ name }}, {{ test_timeout }});
  `TEST_CASE(test_trace);
  `TEST_SUITE_END();

endmodule
