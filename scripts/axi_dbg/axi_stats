#!/usr/bin/env python3

import sys
import math
from axi_bridge_uart import AxiBridgeUart

# TODO: get the cpu freq from register
CPU_FREQ_HZ = 100_000_000

# Each set of registers is at a base address that depends on the number of managers in use.
# The registers are memory mapped to a 32bit address space with the upper bits selecting
# the register set to address. There are a total of (NUM_M * 2 + 2) sets of registers.
# There is a top control register for the entire benchmarking infrastructure (CTRL_TOP) and
# and a REG_STATS at the top level memory interface. Each manager, 1 per NUM_M, has it's
# own CTRL set and a REG_STATS. These are mapped to the following indexes:
#  0: ctrl_top
#  1: stats_top
#  2: manager 0 ctrl
#  3: manager 0 stats
#  4: manager 1 ctrl
#  5: manager 1 stats
#
#  ...
#
#  n+2: manager n ctrl
#  n+3: manager n stats
#
# And each of those indexes is mapped to memory address:
#
#   base_addr = (idx << (32 - $clog2(NUM_M * 2 + 2))

# The word size is not necessarily 32bits, but it usually will be
BYTES_PER_WORD = 4

# the top control regs are at memory base 0
REG_TOP_CTRL = {
    "REG_START": 0,
    "REG_IDLE": 1,
    "REG_NUM_M": 2,
    "REG_CLK_FREQ": 3,
    "REG_CLEAR": 4,
}

REG_CTRL = {
    "REG_BASE_ADDR": 0,
    "REG_BURST_BEATS": 1,
    "REG_BURST_STRIDE": 2,
    "REG_BURST_NUM": 3,
    "REG_BURST_AWSIZE": 4,
}

# Stats register definitions.
REG_STATS = {
    "STAT_AW_BURST_CNT": 0,
    "STAT_AW_DEPTH_MAX": 1,
    "STAT_AW_LEN_MIN": 2,
    "STAT_AW_LEN_MAX": 3,
    "STAT_AW_BYTES_SUM": 4,
    "STAT_AW_BYTES_MIN": 5,
    "STAT_AW_BYTES_MAX": 6,
    "STAT_W_BURST_CNT": 7,
    "STAT_W_DEPTH_MAX": 8,
    "STAT_W_BEAT_CNT": 9,
    "STAT_W_BYTES_SUM": 10,
    "STAT_W_BYTES_MIN": 11,
    "STAT_W_BYTES_MAX": 12,
    "STAT_W_DATA_LAG_CNT": 13,
    "STAT_W_IDLE_CNT": 14,
    "STAT_W_EARLY_BEAT_CNT": 15,
    "STAT_W_AWR_EARLY_CNT": 16,
    "STAT_W_B_LAG_CNT": 17,
    "STAT_W_B_STALL_CNT": 18,
    "STAT_W_B_END_CNT": 19,
    "STAT_W_SLOW_DATA_CNT": 20,
    "STAT_W_STALL_CNT": 21,
    "STAT_W_ADDR_STALL_CNT": 22,
    "STAT_W_ADDR_LAG_CNT": 23,
    "STAT_W_EARLY_STALL_CNT": 24,
    "STAT_W_ERR_CNT": 25,
}

# AXI response codes
AXI_RESP = {0x0: "OKAY", 0x1: "EXOKAY", 0x2: "SLVERR", 0x3: "DECERR"}


def safe_div(numerator, denominator):
    """Safely divide two numbers, return 0 if denominator is 0"""
    return numerator / denominator if denominator else 0


def get_num_managers(axi):
    """Read the number of managers from the top control register"""
    addr = 0 + (REG_TOP_CTRL["REG_NUM_M"] * BYTES_PER_WORD)
    resp, num_m = axi.read_word(addr)
    if resp != 0:
        err = AXI_RESP.get(resp, "UNKNOWN")
        print(f"Error reading NUM_M at 0x{addr:08X}: {err} (0x{resp:02X})")
        sys.exit(1)
    return num_m


def calculate_base_addr(idx, num_m):
    """Calculate the base address for a given register set index based on NUM_M"""
    # Calculate $clog2(NUM_M * 2 + 2) - the number of bits needed to represent all sets
    sel_bits = math.ceil(math.log2(num_m * 2 + 2))
    shift_amount = 32 - sel_bits
    return idx << shift_amount


def read_registers(axi, base_addr=0):
    """Read all statistics registers and return as a dictionary"""
    result = {}
    for name, offset in REG_STATS.items():
        addr = base_addr + (offset * BYTES_PER_WORD)
        resp, value = axi.read_word(addr)
        if resp != 0:
            err = AXI_RESP.get(resp, "UNKNOWN")
            print(f"Error reading {name} at 0x{addr:08X}: {err} (0x{resp:02X})")
            sys.exit(1)
        # Convert register name to lowercase format without STAT_ prefix
        key = name[5:].lower()
        result[key] = value
    return result


def print_raw_stats(stats):
    """Print all raw statistics registers"""
    print("\n# Raw Register Values")
    for idx, (name, offset) in enumerate(REG_STATS.items()):
        # Convert register name to lowercase format without STAT_ prefix
        key = name[5:].lower()
        val = stats.get(key, 0)
        print(f" {offset:02d}\t{key:<18}\t0x{val:<8x}\t{val:<10}")


def print_calculated_stats(block_name, stats, clock_speed_mhz):
    """Print statistics in the requested format"""
    try:
        # Calculate write latency
        write_latency_numerator = (
            stats.get("w_early_beat_cnt", 0)
            + stats.get("w_data_lag_cnt", 0)
            + stats.get("w_early_stall_cnt", 0)
            + stats.get("w_b_stall_cnt", 0)
            + stats.get("w_addr_stall_cnt", 0)
            + stats.get("w_addr_lag_cnt", 0)
            + stats.get("w_b_lag_cnt", 0)
        )
        write_bursts = stats.get("w_burst_cnt", 1)
        write_latency = safe_div(write_latency_numerator, write_bursts)

        # Calculate throughput
        write_beats = stats.get("w_beat_cnt", 0)
        write_throughput_denominator = (
            write_beats
            + stats.get("w_stall_cnt", 0)
            + stats.get("w_awr_early_cnt", 0)
            + stats.get("w_slow_data_cnt", 0)
        )
        write_throughput = safe_div(write_beats, write_throughput_denominator)

        # Calculate bandwidth
        total_write_bytes = stats.get("aw_bytes_sum", 0)
        bandwidth_bytes_per_cycle = safe_div(
            total_write_bytes, write_throughput_denominator
        )

        bandwidth_MBps = bandwidth_bytes_per_cycle * clock_speed_mhz

        print(f"\n# Stats for: {block_name}")
        print(f" {'LATENCY':<12}= {write_latency:8.2f} cycles/burst")
        print(f" {'THROUGHPUT':<12}= {write_throughput:8.2f} beats/cycle")
        print(f" {'BANDWIDTH':<12}= {bandwidth_MBps:8.2f} MB/s")
    except Exception as e:
        print(f" Failed to compute stats for {block_name}: {e}")


def main():
    if len(sys.argv) != 2:
        print("Usage: axi_stats <serial_port>")
        return 1

    serial_port = sys.argv[1]
    block_name = "AXI"
    clock_speed_mhz = CPU_FREQ_HZ / 1_000_000

    try:
        axi = AxiBridgeUart(serial_port)

        # Get the number of managers (NUM_M) from the register
        num_m = get_num_managers(axi)
        print(f"# Detected NUM_M: {num_m}")

        # Calculate the base address for the stats registers using NUM_M
        stats_idx = 1  # stats_top is at index 1
        base_addr = calculate_base_addr(stats_idx, num_m)
        print(f"# Using base address: 0x{base_addr:08X}")

        # Read the stats using the calculated base address
        stats = read_registers(axi, base_addr)

        # Print name and frequency
        print(f"# Name:  {block_name}")
        print(f"# Speed: {clock_speed_mhz} MHz")

        print_raw_stats(stats)
        print_calculated_stats(block_name, stats, clock_speed_mhz)

    except Exception as e:
        print(f"Error: {e}")
        return 1

    axi.close()
    return 0


if __name__ == "__main__":
    sys.exit(main())
