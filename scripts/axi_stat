#!/usr/bin/env python3

# quick hack to convert the axi perf counters to textual names
#
# run with something like:
#
# socat -u /dev/ttyUSB1,b115200 - | scripts/axi_stat
#

import sys
from pprint import pprint

import reprlib

#
# These must match the enum ordering in the rtl for the axi perf stats.
# TODO:: some code gen tool to create these and the sv enum
#
signal_names = [
    "aw_burst_cnt",
    "aw_depth_max",
    "aw_len_min",
    "aw_len_max",
    "aw_bytes_sum",
    "aw_bytes_min",
    "aw_bytes_max",
    "w_burst_cnt",
    "w_depth_max",
    "w_beat_cnt",
    "w_bytes_sum",
    "w_bytes_min",
    "w_bytes_max",
    "w_data_lag_cnt",
    "w_idle_cnt",
    "w_early_beat_cnt",
    "w_awr_early_cnt",
    "w_b_lag_cnt",
    "w_b_stall_cnt",
    "w_b_end_cnt",
    "w_slow_data_cnt",
    "w_stall_cnt",
    "w_addr_stall_cnt",
    "w_addr_lag_cnt",
    "w_early_stall_cnt",
]

# TODO: pass clock speed back with stats
clock_mhz = 100


def safe_div(numerator, denominator):
    return numerator / denominator if denominator else float("nan")


hex_map = {f"{i:02X}": name for i, name in enumerate(signal_names)}
current_block = None
blocks = {}

try:
    for line in sys.stdin:
        line = line.strip()

        if line.startswith("name:"):
            current_block = line.split(":", 1)[1].strip()
            print(f"# Block name: {current_block}")
            blocks[current_block] = {}

        elif ":" in line and line[:2].isalnum() and current_block:
            key, val = line.split(":", 1)
            key = key.strip().upper()
            val = val.strip()
            if key in hex_map:
                stat_name = hex_map[key]
                print(
                    f" {int(key, 16):02d}\t{stat_name:<18}\t{val}\t{int(val, 16)}",
                    file=sys.stderr,
                )
                blocks[current_block][stat_name] = int(val, 16)
except KeyboardInterrupt:
    pass

print("\n# Final stats dump:\n")
pprint(blocks)

# Compute latency, throughput, and bandwidth
for block_name, stats in blocks.items():
    try:
        write_latency_numerator = (
            stats.get("w_early_beat_cnt", 0)
            + stats.get("w_data_lag_cnt", 0)
            + stats.get("w_early_stall_cnt", 0)
            + stats.get("w_b_stall_cnt", 0)
            + stats.get("w_addr_stall_cnt", 0)
            + stats.get("w_addr_lag_cnt", 0)
            + stats.get("w_b_lag_cnt", 0)
        )
        write_bursts = stats.get("w_burst_cnt", 1)
        write_latency = safe_div(write_latency_numerator, write_bursts)

        write_beats = stats.get("w_beat_cnt", 0)
        write_throughput_denominator = (
            write_beats
            + stats.get("w_stall_cnt", 0)
            + stats.get("w_awr_early_cnt", 0)
            + stats.get("w_slow_data_cnt", 0)
        )
        write_throughput = safe_div(write_beats, write_throughput_denominator)

        # Bandwidth = total bytes written / total time (in cycles)
        # Then multiplied by clock frequency (in MHz) to get MB/s
        total_write_bytes = stats.get("w_bytes_sum", 0)
        bandwidth_bytes_per_cycle = safe_div(
            total_write_bytes, write_throughput_denominator
        )

        bandwidth_MBps = bandwidth_bytes_per_cycle * clock_mhz

        print(f"\n# Stats for block: {block_name}", file=sys.stderr)
        print(f"  LATENCY    = {write_latency:.2f} cycles/burst", file=sys.stderr)
        print(f"  THROUGHPUT = {write_throughput:.2f} beats/cycle", file=sys.stderr)
        print(f"  BANDWIDTH  = {bandwidth_MBps:.2f} MB/s", file=sys.stderr)
    except Exception as e:
        print(f"  Failed to compute stats for {block_name}: {e}", file=sys.stderr)
